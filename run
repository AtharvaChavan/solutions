#!/usr/bin/env bash

# unofficial "strict mode": http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'

# TODO: prioritize learning shell to make this shell less shitty
function make-readme {
  hs_count=`find . -type f -name '*.hs' \
                           ! -name '*_test.hs' | wc -l`
  js_count=`find . -type f -name '*.js' \
                           ! -name '*.spec.js' \
                           ! -path '*/node_modules/*' \
                           ! -path '*/elm-stuff/*' | wc -l`
  py_count=`find . -type f -name '*.py' \
                           ! -name '*_test.py' | wc -l`
  clj_count=`find . -type f -name '*.clj' | wc -l`
  cs_count=`find . -type f -name '*.cs' \
                          ! -name '*Test.cs' | wc -l`
  rkt_count=`find . -type f -name '*.rkt' \
                          ! -name '*-test.rkt' | wc -l`
  elm_count=`find . -type f -name '*.elm' \
                          ! -name '*Tests.elm' \
                          ! -path '*/elm-stuff/*' | wc -l`

  echo "
My solutions for problems from Exercism, Leetcode, Project Euler etc in a
number of languages. Mostly an exercise in side-by-side comparison of languages,
to increase my understanding of those I don't use day to day.

Stats
===

| Language | Problems solved |
| --- | ---: |
| Clojure | ${clj_count} |
| Python | ${py_count} |
| JavaScript | ${js_count} |
| Racket | ${rkt_count} |
| C# | ${cs_count} |
| Haskell | ${hs_count} |
| Elm | ${elm_count} |
| x86 assembly | 0 |
| c | 0 |
| c# | 0 |
| c++ | 0 |
| Clojure | 0 |
| Elixer | 0 |
| Go | 0 |
| J | 0 |
| Java | 0 |
| Lua | 0 |
| Octave | 0 |
| OCaml | 0 |
| POSIX shell | 0 |
| Prolog | 0 |
| Rust | 0 |
" > readme.md
}


function prep-all {
  touch "$1.txt"

  if [ ! -e "$1.js" ] ; then echo '#!/usr/bin/env node' > "$1.js"; fi
  if [ ! -e "$1.hs" ] ; then echo '#!/usr/bin/env runghc' > "$1.hs"; fi
  # if [ ! -e "$1.ml" ] ; then echo '#!/usr/bin/env ocaml' > "$1.ml"; fi
  if [ ! -e "$1.py" ] ; then echo '#!/usr/bin/env python' > "$1.py"; fi
  if [ ! -e "$1.clj" ] ; then echo '#!/usr/bin/env lein-exec' > "$1.clj"; fi
  if [ ! -e "$1.rkt" ] ; then echo '#!/usr/bin/env racket --script' > "$1.rkt"; fi

  chmod +x $1.*
}

# compile and run c sharp
function cs {
  mcs -out:/tmp/out.exe "$1" && mono /tmp/out.exe
}


# if called with interpreter, run fn that matches first arg
[[ $BASH_SOURCE = "$0" ]] && eval "$1" "${@:2}"
